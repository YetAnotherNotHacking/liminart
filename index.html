<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pixel Canvas</title>
    <style>
        :root {
            --bg-color: #1a1a1a;
            --text-color: #e0e0e0;
            --accent-color: #4a9eff;
            --error-color: #ff4444;
            --success-color: #44ff44;
            --warning-color: #ffaa00;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: Arial, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            overflow: hidden;
            height: 100vh;
            width: 100vw;
            display: flex;
            flex-direction: column;
        }

        .toolbar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            background-color: rgba(0, 0, 0, 0.4);
            
            border-bottom: 1px solid #333;
            z-index: 10;
        }

        .toolbar-section {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .auth-section {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-left: auto;
        }

        .auth-btn {
            padding: 6px 12px;
            background: rgba(0, 0, 0, 0.6);
            color: var(--text-color);
            border: 1px solid #444;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            transition: background 0.2s;
        }

        .auth-btn:hover {
            background: rgba(0, 0, 0, 0.8);
        }

        .user-info {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 4px 8px;
            background: rgba(0, 0, 0, 0.6);
            border-radius: 4px;
            font-size: 12px;
        }

        .user-avatar {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: #666;
            border: 1px solid #888;
        }

        .auth-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            z-index: 2000;
            align-items: center;
            justify-content: center;
        }

        .auth-modal.active {
            display: flex;
        }

        .auth-modal-content {
            background: var(--bg-color);
            border: 1px solid #444;
            border-radius: 8px;
            padding: 24px;
            max-width: 400px;
            width: 90%;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
        }

        .auth-modal h2 {
            margin: 0 0 20px 0;
            color: var(--accent-color);
            text-align: center;
        }

        .auth-form {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .auth-input {
            padding: 10px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid #555;
            border-radius: 4px;
            color: var(--text-color);
            font-size: 14px;
        }

        .auth-input:focus {
            outline: none;
            border-color: var(--accent-color);
        }

        .auth-submit {
            padding: 12px;
            background: var(--accent-color);
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
        }

        .auth-submit:hover {
            background: #3a8ae6;
        }

        .auth-submit:disabled {
            background: #666;
            cursor: not-allowed;
        }

        .auth-switch {
            text-align: center;
            margin-top: 16px;
            color: #ccc;
        }

        .auth-switch a {
            color: var(--accent-color);
            cursor: pointer;
            text-decoration: none;
        }

        .auth-switch a:hover {
            text-decoration: underline;
        }

        .auth-close {
            position: absolute;
            top: 8px;
            right: 12px;
            background: none;
            border: none;
            color: #ccc;
            cursor: pointer;
            font-size: 20px;
        }

        .color-palette {
            display: flex;
            gap: 5px;
            flex-wrap: wrap;
            max-width: 50vw;
        }

        .color-button {
            width: 24px;
            height: 24px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: transform 0.1s;
            margin: 2px;
            position: relative;
        }

        .color-button:hover {
            transform: scale(1.1);
        }

        .color-button.selected {
            box-shadow: 0 0 0 2px white, 0 0 0 4px black;
            transform: scale(1.1);
        }

        .current-color-display {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-right: 10px;
            background: rgba(0, 0, 0, 0.3);
            padding: 5px;
            border-radius: 4px;
            border: 1px solid #444;
        }

        #currentColorPreview {
            width: 36px;
            height: 36px;
            border-radius: 4px;
            border: 1px solid #666;
            margin-bottom: 3px;
            background-color: #FF4500;
        }

        #currentColorText {
            font-size: 12px;
            font-family: monospace;
        }

        .custom-color-picker {
            display: flex;
            align-items: center;
            gap: 5px;
            margin-left: 10px;
            background: rgba(0, 0, 0, 0.3);
            padding: 5px;
            border-radius: 4px;
            border: 1px solid #444;
        }

        #customColorInput {
            width: 36px;
            height: 36px;
            border: none;
            background: none;
            padding: 0;
            cursor: pointer;
        }

        #addCustomColorBtn {
            width: 28px;
            height: 28px;
            padding: 0;
            font-size: 16px;
        }

        .canvas-container {
            position: relative;
            flex: 1;
            overflow: hidden;
            background: #0a0a0a;
            cursor: crosshair;
        }

        .pixel-canvas {
            position: absolute;
            transform-origin: 0 0;
            image-rendering: pixelated;
        }

        .tile {
            position: absolute;
            image-rendering: pixelated;
            background-color: rgba(255,255,255,0.05);
        }

        .coordinates {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 12px;
            z-index: 5;
        }

        .controls {
            position: absolute;
            bottom: 10px;
            right: 10px;
            display: flex;
            flex-direction: column;
            gap: 5px;
            z-index: 5;
        }

        .control-btn {
            width: 36px;
            height: 36px;
            background: rgba(0, 0, 0, 0.7);
            color: var(--text-color);
            border: 1px solid #333;
            border-radius: 4px;
            font-size: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .stats {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.7);
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 12px;
            z-index: 5;
            visibility: hidden; /* Hide stats until loaded */
        }

        .notification {
            position: fixed;
            top: 70px;
            right: 20px;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 10px 15px;
            border-radius: 4px;
            max-width: 300px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
            z-index: 1000;
            transition: transform 0.3s, opacity 0.3s;
            animation: slideIn 0.3s forwards;
        }

        .notification.error {
            border-left: 3px solid var(--error-color);
        }

        .notification.success {
            border-left: 3px solid var(--success-color);
        }

        .notification.warning {
            border-left: 3px solid var(--warning-color);
        }

        .fade-out {
            animation: fadeOut 0.5s forwards;
        }

        .loading {
            position: fixed;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 8px 15px;
            border-radius: 4px;
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
        }

        .loading.visible {
            opacity: 1;
        }

        @keyframes slideIn {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }

        @keyframes fadeOut {
            from { opacity: 1; }
            to { opacity: 0; transform: translateY(-20px); }
        }

        @media (max-width: 768px) {
            .toolbar {
                flex-direction: column;
                gap: 10px;
                align-items: flex-start;
            }
            
            .color-palette {
                max-width: 100%;
            }
            
            .current-color-display {
                flex-direction: row;
                width: 100%;
                justify-content: center;
                margin-right: 0;
                margin-bottom: 5px;
            }
            
            #currentColorPreview {
                margin-bottom: 0;
                margin-right: 10px;
            }
            
            .custom-color-picker {
                margin-left: 0;
                margin-top: 5px;
                width: 100%;
                justify-content: center;
            }
        }
    </style>
</head>
<body>
    <div class="toolbar">
        <div class="toolbar-section">
            <div class="current-color-display">
                <div id="currentColorPreview"></div>
                <div id="currentColorText">#FF4500</div>
            </div>
            <div class="color-palette" id="colorPalette">
                <button class="color-button" style="background-color: #BE0039"></button>
                <button class="color-button selected" style="background-color: #FF4500"></button>
                <button class="color-button" style="background-color: #FFA800"></button>
                <button class="color-button" style="background-color: #FFD635"></button>
                <button class="color-button" style="background-color: #00A368"></button>
                <button class="color-button" style="background-color: #00CC78"></button>
                <button class="color-button" style="background-color: #7EED56"></button>
                <button class="color-button" style="background-color: #51E9F4"></button>
                <button class="color-button" style="background-color: #3690EA"></button>
                <button class="color-button" style="background-color: #2450A4"></button>
                <button class="color-button" style="background-color: #B44AC0"></button>
                <button class="color-button" style="background-color: #FF99AA"></button>
                <button class="color-button" style="background-color: #000000"></button>
                <button class="color-button" style="background-color: #898D90"></button>
                <button class="color-button" style="background-color: #FFFFFF"></button>
            </div>
            <div class="custom-color-picker">
                <input type="color" id="customColorInput" value="#FF4500">
                <button id="addCustomColorBtn" class="control-btn" title="Use Custom Color">+</button>
            </div>
        </div>
        <div class="toolbar-section">
            <button id="debugBtn" class="control-btn">üîç</button>
            <button id="resetBtn" class="control-btn">‚ü≤</button>
        </div>
        <div class="auth-section" id="authSection">
            <!-- Will be populated by JavaScript -->
        </div>
    </div>

    <div class="canvas-container" id="canvasContainer">
        <div class="pixel-canvas" id="pixelCanvas"></div>
        <div class="coordinates" id="coordinates">X: 0, Y: 0</div>
        <div class="controls">
            <button class="control-btn" id="zoomInBtn">+</button>
            <button class="control-btn" id="zoomOutBtn">-</button>
        </div>
        <div class="stats" id="stats">Loading stats...</div>
    </div>

    <div class="loading" id="loading">Loading tiles...</div>

    <!-- Authentication Modals -->
    <div class="auth-modal" id="authModal">
        <div class="auth-modal-content">
            <button class="auth-close" onclick="closeAuthModal()">&times;</button>
            <div id="loginForm" class="auth-form-container">
                <h2>Login to Pixel Canvas</h2>
                <form class="auth-form" onsubmit="handleLogin(event)">
                    <input type="text" class="auth-input" placeholder="Username" name="username" required>
                    <input type="password" class="auth-input" placeholder="Password" name="password" required>
                    <button type="submit" class="auth-submit">Login</button>
                </form>
                <div class="auth-switch">
                    Don't have an account? <a onclick="switchToRegister()">Register</a>
                </div>
            </div>
            <div id="registerForm" class="auth-form-container" style="display: none;">
                <h2>Create Account</h2>
                <form class="auth-form" onsubmit="handleRegister(event)">
                    <input type="text" class="auth-input" placeholder="Username (3-50 chars)" name="username" required minlength="3" maxlength="50">
                    <input type="email" class="auth-input" placeholder="Email" name="email" required>
                    <input type="password" class="auth-input" placeholder="Password (min 8 chars)" name="password" required minlength="8">
                    <input type="text" class="auth-input" placeholder="Display Name (optional)" name="displayName" maxlength="100">
                    <button type="submit" class="auth-submit">Register</button>
                </form>
                <div class="auth-switch">
                    Already have an account? <a onclick="switchToLogin()">Login</a>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Configuration
        const TILE_SIZE = 128; // Match the Python server's tile size
        const BOARD_SIZE = 1024; // Match the Python server's canvas size
        const TILE_COUNT = BOARD_SIZE / TILE_SIZE;
        const API_BASE = 'https://silverflag.net:6969/api';
        
        // State variables
        let scale = 1;
        let offsetX = 0;
        let offsetY = 0;
        let selectedColor = '#000000';
        let lastUpdateTimestamp = 0;
        
        // Authentication state
        let currentUser = null;
        let authToken = localStorage.getItem('token');
        let isDragging = false;
        let dragStartX = 0;
        let dragStartY = 0;
        let dragStartOffsetX = 0;
        let dragStartOffsetY = 0;
        let loadedTiles = new Set();
        let tileElements = {};
        let visibleTiles = new Set();
        
        // Movement state for WASD controls
        const keyState = {
            w: false,
            a: false,
            s: false,
            d: false
        };
        let movementAnimationFrame = null;
        let lastMoveTime = 0;
        
        // Add a tracker for tile update timestamps to avoid race conditions
        const tileUpdateTimestamps = {};
        
        // Add tile checksum tracking to the state variables
        let tileChecksums = {};
        
        // Add these variables to the state variables section (around line 224)
        let lastPlacedTile = null;
        let tileLocalChanges = {};
        let consecutivePlacementMode = false;
        let batchPlacementInProgress = false;
        
        // DOM Elements
        const canvasContainer = document.getElementById('canvasContainer');
        const pixelCanvas = document.getElementById('pixelCanvas');
        const colorPalette = document.getElementById('colorPalette');
        const coordinates = document.getElementById('coordinates');
        const stats = document.getElementById('stats');
        const zoomInBtn = document.getElementById('zoomInBtn');
        const zoomOutBtn = document.getElementById('zoomOutBtn');
        const resetBtn = document.getElementById('resetBtn');
        const debugBtn = document.getElementById('debugBtn');
        const loading = document.getElementById('loading');
        
        // Initialize the application
        init();
        
        // Check for email verification token in URL
        const urlParams = new URLSearchParams(window.location.search);
        const verifyToken = urlParams.get('verify');
        if (verifyToken) {
            verifyEmail(verifyToken);
        }
        
        async function verifyEmail(token) {
            try {
                const response = await fetch(`${API_BASE}/auth/verify-email`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ token })
                });
                
                const data = await response.json();
                
                if (response.ok) {
                    showNotification('Email verified successfully! You can now login.', 'success', 5000);
                    // Remove the token from URL
                    window.history.replaceState({}, document.title, window.location.pathname);
                } else {
                    showNotification(data.detail || 'Email verification failed', 'error');
                }
            } catch (error) {
                showNotification('Email verification failed: ' + error.message, 'error');
            }
        }
        
        // Authentication Functions
        function getAuthHeaders() {
            const headers = { 'Content-Type': 'application/json' };
            if (authToken) {
                headers['Authorization'] = `Bearer ${authToken}`;
            }
            return headers;
        }
        
        async function initAuth() {
            if (authToken) {
                try {
                    const response = await fetch(`${API_BASE}/auth/me`, {
                        headers: getAuthHeaders()
                    });
                    
                    if (response.ok) {
                        currentUser = await response.json();
                        updateAuthUI();
                    } else {
                        // Token is invalid, clear it
                        localStorage.removeItem('token');
                        authToken = null;
                        updateAuthUI();
                    }
                } catch (error) {
                    console.error('Auth check failed:', error);
                    updateAuthUI();
                }
            } else {
                updateAuthUI();
            }
        }
        
        function updateAuthUI() {
            const authSection = document.getElementById('authSection');
            
            if (currentUser) {
                authSection.innerHTML = `
                    <div class="user-info">
                        <img class="user-avatar" src="${API_BASE}/user/profile-picture/${currentUser.id}" 
                             onerror="this.style.display='none'" alt="Avatar">
                        <span>${currentUser.display_name || currentUser.username}</span>
                        <button class="auth-btn" onclick="logout()">Logout</button>
                    </div>
                `;
            } else {
                authSection.innerHTML = `
                    <button class="auth-btn" onclick="showLogin()">Login</button>
                    <button class="auth-btn" onclick="showRegister()">Register</button>
                `;
            }
        }
        
        function showLogin() {
            document.getElementById('authModal').classList.add('active');
            document.getElementById('loginForm').style.display = 'block';
            document.getElementById('registerForm').style.display = 'none';
        }
        
        function showRegister() {
            document.getElementById('authModal').classList.add('active');
            document.getElementById('loginForm').style.display = 'none';
            document.getElementById('registerForm').style.display = 'block';
        }
        
        function switchToLogin() {
            document.getElementById('loginForm').style.display = 'block';
            document.getElementById('registerForm').style.display = 'none';
        }
        
        function switchToRegister() {
            document.getElementById('loginForm').style.display = 'none';
            document.getElementById('registerForm').style.display = 'block';
        }
        
        function closeAuthModal() {
            document.getElementById('authModal').classList.remove('active');
        }
        
        async function handleLogin(event) {
            event.preventDefault();
            const form = event.target;
            const submitBtn = form.querySelector('.auth-submit');
            
            submitBtn.disabled = true;
            submitBtn.textContent = 'Logging in...';
            
            try {
                const response = await fetch(`${API_BASE}/auth/login`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        username: form.username.value,
                        password: form.password.value
                    })
                });
                
                const data = await response.json();
                
                if (response.ok) {
                    authToken = data.access_token;
                    localStorage.setItem('token', authToken);
                    
                    // Get user info
                    const userResponse = await fetch(`${API_BASE}/auth/me`, {
                        headers: getAuthHeaders()
                    });
                    
                    if (userResponse.ok) {
                        currentUser = await userResponse.json();
                        closeAuthModal();
                        updateAuthUI();
                        showNotification('Login successful!', 'success');
                        form.reset();
                    }
                } else {
                    showNotification(data.detail || 'Login failed', 'error');
                }
            } catch (error) {
                showNotification('Login failed: ' + error.message, 'error');
            } finally {
                submitBtn.disabled = false;
                submitBtn.textContent = 'Login';
            }
        }
        
        async function handleRegister(event) {
            event.preventDefault();
            const form = event.target;
            const submitBtn = form.querySelector('.auth-submit');
            
            submitBtn.disabled = true;
            submitBtn.textContent = 'Registering...';
            
            try {
                const response = await fetch(`${API_BASE}/auth/register`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        username: form.username.value,
                        email: form.email.value,
                        password: form.password.value,
                        display_name: form.displayName.value || null
                    })
                });
                
                const data = await response.json();
                
                if (response.ok) {
                    showNotification('Registration successful! Please check your email to verify your account.', 'success', 5000);
                    closeAuthModal();
                    form.reset();
                } else {
                    showNotification(data.detail || 'Registration failed', 'error');
                }
            } catch (error) {
                showNotification('Registration failed: ' + error.message, 'error');
            } finally {
                submitBtn.disabled = false;
                submitBtn.textContent = 'Register';
            }
        }
        
        function logout() {
            localStorage.removeItem('token');
            authToken = null;
            currentUser = null;
            updateAuthUI();
            showNotification('Logged out successfully', 'success');
        }
        
        function init() {
            // Initialize authentication first
            initAuth();
            
            // Setup initial canvas state
            updateCanvasTransform();
            
            // Add checker pattern style
            addCheckerPatternStyle();
            
            // Setup color palette (use existing HTML buttons now)
            initColorPalette();
            
            // Setup event listeners
            setupEventListeners();
            
            // Start app by centering and loading board
            centerCanvas();
            fetchBoardInfo()
                .then(() => {
                    updateVisibleTiles();
                    loadVisibleTiles();
                    startUpdateCycle();
                })
                .catch(err => {
                    showNotification('Failed to initialize canvas. ' + err.message, 'error');
                    console.error('Initialization error:', err);
                    
                    // Try to continue anyway with defaults
                    updateVisibleTiles();
                    loadVisibleTiles();
                    startUpdateCycle();
                });
        }
        
        function initColorPalette() {
            // Since we now use static HTML buttons, just set up event listeners
            document.querySelectorAll('.color-button').forEach(btn => {
                btn.addEventListener('click', () => {
                    // Remove selected from all buttons
                    document.querySelectorAll('.color-button').forEach(b => b.classList.remove('selected'));
                    // Add selected to this button
                    btn.classList.add('selected');
                    // Update selected color
                    selectedColor = btn.style.backgroundColor;
                    
                    // Convert RGB to hex if needed
                    if (selectedColor.startsWith('rgb')) {
                        const rgb = selectedColor.match(/\d+/g).map(Number);
                        selectedColor = rgbToHex(rgb[0], rgb[1], rgb[2]);
                    }
                    
                    // Update the current color display
                    updateColorDisplay(selectedColor);
                });
            });
            
            // Use first button's color as default
            const firstBtn = document.querySelector('.color-button');
            if (firstBtn) {
                selectedColor = firstBtn.style.backgroundColor;
                // Convert RGB to hex if needed
                if (selectedColor.startsWith('rgb')) {
                    const rgb = selectedColor.match(/\d+/g).map(Number);
                    selectedColor = rgbToHex(rgb[0], rgb[1], rgb[2]);
                }
                
                // Initialize the current color display
                updateColorDisplay(selectedColor);
            }
            
            // Set up custom color picker
            const customColorInput = document.getElementById('customColorInput');
            const addCustomColorBtn = document.getElementById('addCustomColorBtn');
            
            // Update custom color input to match the initial color
            customColorInput.value = selectedColor;
            
            // When color input changes, update the preview but don't select yet
            customColorInput.addEventListener('input', () => {
                customColorInput.style.backgroundColor = customColorInput.value;
            });
            
            // When add button is clicked, select the custom color
            addCustomColorBtn.addEventListener('click', () => {
                // Remove selected from all buttons
                document.querySelectorAll('.color-button').forEach(b => b.classList.remove('selected'));
                
                // Update selected color
                selectedColor = customColorInput.value;
                
                // Update the current color display
                updateColorDisplay(selectedColor);
            });
        }
        
        // Helper function to convert RGB to hex
        function rgbToHex(r, g, b) {
            return '#' + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1).toUpperCase();
        }
        
        function setupEventListeners() {
            // No setup button needed for Python backend
            
            // Canvas interaction events
            canvasContainer.addEventListener('mousedown', handleMouseDown);
            document.addEventListener('mousemove', handleMouseMove);
            document.addEventListener('mouseup', handleMouseUp);
            canvasContainer.addEventListener('click', handleCanvasClick);
            canvasContainer.addEventListener('contextmenu', e => e.preventDefault());
            
            // Add this new listener for continuous drawing
            canvasContainer.addEventListener('mousemove', handleCanvasMouseMove);
            
            // Mobile touch events
            canvasContainer.addEventListener('touchstart', handleTouchStart);
            document.addEventListener('touchmove', handleTouchMove);
            document.addEventListener('touchend', handleTouchEnd);
            
            // Zoom buttons
            zoomInBtn.addEventListener('click', () => {
                scale = Math.min(scale * 1.5, 20);
                updateCanvasTransform();
                updateVisibleTiles();
                loadVisibleTiles();
            });
            
            zoomOutBtn.addEventListener('click', () => {
                scale = Math.max(scale / 1.5, 0.25);
                updateCanvasTransform();
                updateVisibleTiles();
                loadVisibleTiles();
            });
            
            // Mouse wheel for zooming
            canvasContainer.addEventListener('wheel', handleWheel, { passive: false });
            
            // Reset button
            resetBtn.addEventListener('click', centerCanvas);
            
            // Debug button - could open a stats page later
            debugBtn.addEventListener('click', () => {
                if (currentUser) {
                    showNotification('User stats feature coming soon!', 'info');
                } else {
                    showNotification('Login to see stats', 'warning');
                }
            });
            
            // Keyboard controls (WASD)
            window.addEventListener('keydown', handleKeyDown);
            window.addEventListener('keyup', handleKeyUp);
            
            // Window resize
            window.addEventListener('resize', handleResize);
        }

        function addCheckerPatternStyle() {
            // Create a small checker pattern as a data URL
            const canvas = document.createElement('canvas');
            const size = 8; // Size of the checker pattern (8x8 pixels)
            canvas.width = size * 2;
            canvas.height = size * 2;
            
            const ctx = canvas.getContext('2d');
            // Fill with dark gray
            ctx.fillStyle = '#222222';
            ctx.fillRect(0, 0, size * 2, size * 2);
            
            // Add light gray checkers
            ctx.fillStyle = '#444444';
            ctx.fillRect(0, 0, size, size);
            ctx.fillRect(size, size, size, size);
            
            // Convert to data URL
            const dataURL = canvas.toDataURL('image/png');
            
            // Create and inject the CSS
            const style = document.createElement('style');
            style.textContent = `
                .tile {
                    position: absolute;
                    image-rendering: pixelated;
                    background-image: url('${dataURL}');
                    background-repeat: repeat;
                }
            `;
            
            document.head.appendChild(style);
        }

        function renderEmptyTile(tileKey) {
            const tile = tileElements[tileKey];
            if (!tile) return;
            
            const ctx = tile.getContext('2d');
            
            // Clear the tile with transparent background to show the checker pattern
            ctx.clearRect(0, 0, TILE_SIZE, TILE_SIZE);
            
            // Draw grid lines only
            ctx.strokeStyle = '#666666';
            ctx.lineWidth = 0.5;
            
            // Draw grid lines
            for (let i = 0; i <= TILE_SIZE; i += 16) {
                // Vertical line
                ctx.beginPath();
                ctx.moveTo(i, 0);
                ctx.lineTo(i, TILE_SIZE);
                ctx.stroke();
                
                // Horizontal line
                ctx.beginPath();
                ctx.moveTo(0, i);
                ctx.lineTo(TILE_SIZE, i);
                ctx.stroke();
            }
        }

        
        function handleMouseDown(e) {
            if (e.button === 0) { // Left click
                // Will be handled by click event for placing pixels
            } else if (e.button === 1 || e.button === 2) { // Middle or right click for panning
                e.preventDefault();
                isDragging = true;
                dragStartX = e.clientX;
                dragStartY = e.clientY;
                dragStartOffsetX = offsetX;
                dragStartOffsetY = offsetY;
                canvasContainer.style.cursor = 'grabbing';
            }
        }
        
        function handleMouseMove(e) {
            updateCursorPosition(e.clientX, e.clientY);
            
            if (isDragging) {
                offsetX = dragStartOffsetX + (e.clientX - dragStartX);
                offsetY = dragStartOffsetY + (e.clientY - dragStartY);
                updateCanvasTransform();
            }
        }
        
        function handleMouseUp() {
            if (isDragging) {
                isDragging = false;
                canvasContainer.style.cursor = 'crosshair';
                updateVisibleTiles();
                loadVisibleTiles();
            }
        }
        
        function handleCanvasClick(e) {
            if (e.shiftKey) {
                // When shift is held, enter/exit continuous placement mode
                consecutivePlacementMode = !consecutivePlacementMode;
                if (consecutivePlacementMode) {
                    showNotification('Continuous placement mode activated - click and drag to place pixels', 'info', 1500);
                } else {
                    showNotification('Continuous placement mode deactivated', 'info', 1500);
                }
                return;
            }
            
            const rect = canvasContainer.getBoundingClientRect();
            const canvasX = Math.floor((e.clientX - rect.left - offsetX) / scale);
            const canvasY = Math.floor((e.clientY - rect.top - offsetY) / scale);
            
            // Ensure coordinates are within board bounds
            if (canvasX >= 0 && canvasX < BOARD_SIZE && canvasY >= 0 && canvasY < BOARD_SIZE) {
                placePixel(canvasX, canvasY);
            }
        }
        
        function handleTouchStart(e) {
            if (e.touches.length === 1) {
                // Single touch for placing pixels will be handled by click handler
            } else if (e.touches.length === 2) {
                // Enable panning with two fingers
                e.preventDefault();
                isDragging = true;
                dragStartX = e.touches[0].clientX;
                dragStartY = e.touches[0].clientY;
                dragStartOffsetX = offsetX;
                dragStartOffsetY = offsetY;
            }
        }
        
        function handleTouchMove(e) {
            if (e.touches.length === 1) {
                updateCursorPosition(e.touches[0].clientX, e.touches[0].clientY);
            }
            
            if (isDragging && e.touches.length >= 1) {
                e.preventDefault();
                offsetX = dragStartOffsetX + (e.touches[0].clientX - dragStartX);
                offsetY = dragStartOffsetY + (e.touches[0].clientY - dragStartY);
                updateCanvasTransform();
            }
        }
        
        function handleTouchEnd() {
            if (isDragging) {
                isDragging = false;
                updateVisibleTiles();
                loadVisibleTiles();
            }
        }
        
        function handleWheel(e) {
            e.preventDefault();
            
            // Get cursor position relative to canvas before zoom
            const rect = canvasContainer.getBoundingClientRect();
            const cursorX = e.clientX - rect.left;
            const cursorY = e.clientY - rect.top;
            
            // Calculate cursor position in board space
            const boardX = (cursorX - offsetX) / scale;
            const boardY = (cursorY - offsetY) / scale;
            
            // Adjust scale based on wheel direction
            const scaleFactor = e.deltaY < 0 ? 1.1 : 0.9;
            scale = Math.max(0.25, Math.min(20, scale * scaleFactor));
            
            // Calculate new cursor position after scale
            const newCursorX = boardX * scale + offsetX;
            const newCursorY = boardY * scale + offsetY;
            
            // Adjust offset to zoom toward cursor
            offsetX += cursorX - newCursorX;
            offsetY += cursorY - newCursorY;
            
            updateCanvasTransform();
            updateVisibleTiles();
            loadVisibleTiles();
        }
        
        function handleKeyDown(e) {
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
            
            const key = e.key.toLowerCase();
            
            if (key === 'w' || key === 'a' || key === 's' || key === 'd') {
                e.preventDefault();
                keyState[key] = true;
                
                if (!movementAnimationFrame) {
                    lastMoveTime = performance.now();
                    movementAnimationFrame = requestAnimationFrame(handleSmoothMovement);
                }
            }
        }
        
        function handleKeyUp(e) {
            const key = e.key.toLowerCase();
            
            if (key === 'w' || key === 'a' || key === 's' || key === 'd') {
                keyState[key] = false;
                
                if (!keyState.w && !keyState.a && !keyState.s && !keyState.d) {
                    if (movementAnimationFrame) {
                        cancelAnimationFrame(movementAnimationFrame);
                        movementAnimationFrame = null;
                    }
                    
                    updateVisibleTiles();
                    loadVisibleTiles();
                }
            }
        }
        
        function handleSmoothMovement() {
            const now = performance.now();
            const deltaTime = now - lastMoveTime;
            lastMoveTime = now;
            
            // Scale speed inversely with zoom level (faster when zoomed in)
            const baseSpeed = 120;
            const moveSpeed = baseSpeed * (deltaTime / 1000) / (1 / scale);
            
            let moved = false;
            
            if (keyState.w) {
                offsetY += moveSpeed;
                moved = true;
            }
            
            if (keyState.s) {
                offsetY -= moveSpeed;
                moved = true;
            }
            
            if (keyState.a) {
                offsetX += moveSpeed;
                moved = true;
            }
            
            if (keyState.d) {
                offsetX -= moveSpeed;
                moved = true;
            }
            
            if (moved) {
                updateCanvasTransform();
                
                // Only update visible tiles occasionally during movement
                if (now % 200 < 20) {
                    updateVisibleTiles();
                    loadVisibleTiles();
                }
                
                movementAnimationFrame = requestAnimationFrame(handleSmoothMovement);
            } else {
                movementAnimationFrame = null;
            }
        }
        
        function handleResize() {
            updateCanvasTransform();
            updateVisibleTiles();
            loadVisibleTiles();
        }
        
        function updateCursorPosition(clientX, clientY) {
            const rect = canvasContainer.getBoundingClientRect();
            const canvasX = Math.floor((clientX - rect.left - offsetX) / scale);
            const canvasY = Math.floor((clientY - rect.top - offsetY) / scale);
            
            if (canvasX >= 0 && canvasX < BOARD_SIZE && canvasY >= 0 && canvasY < BOARD_SIZE) {
                coordinates.textContent = `X: ${canvasX}, Y: ${canvasY}`;
            } else {
                coordinates.textContent = 'Out of bounds';
            }
        }
        
        function updateCanvasTransform() {
            pixelCanvas.style.transform = `translate(${offsetX}px, ${offsetY}px) scale(${scale})`;
        }
        
        function centerCanvas() {
            const container = canvasContainer.getBoundingClientRect();
            scale = 1;
            offsetX = (container.width / 2) - (BOARD_SIZE * scale / 2);
            offsetY = (container.height / 2) - (BOARD_SIZE * scale / 2);
            updateCanvasTransform();
            updateVisibleTiles();
            loadVisibleTiles();
        }
        
        async function fetchBoardInfo() {
            showLoading(true);
            
            try {
                // Get basic canvas info - use state endpoint to get dimensions
                const response = await fetch(`${API_BASE}/state?tile_x=0&tile_y=0`, {
                    headers: getAuthHeaders()
                });
                
                if (!response.ok) {
                    throw new Error(`Server responded with status: ${response.status}`);
                }
                
                const data = await response.json();
                
                console.log("Board info loaded", data);
                lastUpdateTimestamp = Date.now();
                
            } catch (error) {
                console.error("Error fetching board info:", error);
                throw error;
            } finally {
                showLoading(false);
            }
        }
        
        function updateVisibleTiles() {
            // Clear previous visible tiles
            visibleTiles.clear();
            
            const rect = canvasContainer.getBoundingClientRect();
            
            // Calculate visible tile range
            const minVisibleX = Math.floor((0 - offsetX) / scale / TILE_SIZE);
            const minVisibleY = Math.floor((0 - offsetY) / scale / TILE_SIZE);
            const maxVisibleX = Math.ceil((rect.width - offsetX) / scale / TILE_SIZE);
            const maxVisibleY = Math.ceil((rect.height - offsetY) / scale / TILE_SIZE);
            
            // Clamp to board boundaries and add buffer
            const startTileX = Math.max(0, minVisibleX - 1);
            const startTileY = Math.max(0, minVisibleY - 1);
            const endTileX = Math.min(TILE_COUNT - 1, maxVisibleX + 1);
            const endTileY = Math.min(TILE_COUNT - 1, maxVisibleY + 1);
            
            // Add all visible tiles
            for (let tileY = startTileY; tileY <= endTileY; tileY++) {
                for (let tileX = startTileX; tileX <= endTileX; tileX++) {
                    visibleTiles.add(`${tileX},${tileY}`);
                }
            }
        }
        
        function loadVisibleTiles() {
            // Load all currently visible tiles
            for (const tileKey of visibleTiles) {
                loadTile(tileKey);
            }
        }
        
        async function loadTile(tileKey, forceReload = false) {
            // Skip if already loaded and not forcing a reload
            if (loadedTiles.has(tileKey) && !forceReload) return;
            
            const [tileX, tileY] = tileKey.split(',').map(Number);
            
            // Save the request timestamp to detect race conditions
            const requestTimestamp = Date.now();
            
            // Mark as loading to prevent duplicate requests
            loadedTiles.add(tileKey);
            
            // Create the tile element if it doesn't exist
            if (!tileElements[tileKey]) {
                const tile = document.createElement('canvas');
                tile.width = TILE_SIZE;
                tile.height = TILE_SIZE;
                tile.className = 'tile';
                tile.style.left = `${tileX * TILE_SIZE}px`;
                tile.style.top = `${tileY * TILE_SIZE}px`;
                
                pixelCanvas.appendChild(tile);
                tileElements[tileKey] = tile;
            }
            
            // Load tile data from server with retries
            let retryCount = 0;
            const maxRetries = 2;
            
            while (retryCount <= maxRetries) {
                try {
                    showLoading(true);
                    
                    // Add timestamp to prevent caching issues
                    const timestamp = Date.now();
                    const response = await fetch(`${API_BASE}/state?tile_x=${tileX}&tile_y=${tileY}&t=${timestamp}`, {
                        headers: getAuthHeaders()
                    });
                    
                    if (!response.ok) {
                        if (response.status === 500 && retryCount < maxRetries) {
                            // Server error - retry after delay
                            retryCount++;
                            await new Promise(resolve => setTimeout(resolve, 500 * retryCount));
                            continue;
                        }
                        
                        // If we've reached max retries or it's not a 500 error
                        if (retryCount === 0) {
                            console.error(`Error loading tile ${tileKey}: Server responded with status: ${response.status}`);
                        }
                        
                        // Just render an empty tile and continue
                        renderEmptyTile(tileKey);
                        return;
                    }
                    
                    const data = await response.json();
                    
                    // Check if there was a more recent local update to this tile
                    // If so, don't overwrite it with the server data
                    const lastLocalUpdate = tileUpdateTimestamps[tileKey] || 0;
                    const shouldRender = forceReload || !lastLocalUpdate || lastLocalUpdate < requestTimestamp;
                    
                    // Handle new Python API format
                    if (data.tiles && data.tiles.length > 0) {
                        const tileData = data.tiles[0];
                        
                        if (shouldRender) {
                            // Decode base64 tile data
                            const decodedData = atob(tileData.data);
                            const pixels = [];
                            
                            if (decodedData.trim()) {
                                const pixelStrings = decodedData.split('|');
                                for (const pixelStr of pixelStrings) {
                                    if (pixelStr.trim()) {
                                        const [x, y, r, g, b] = pixelStr.split(',').map(Number);
                                        pixels.push({ x, y, r, g, b });
                                    }
                                }
                            }
                            
                            renderTile(tileKey, pixels, false);
                            
                            // Store the checksum if available
                            if (tileData.checksum) {
                                tileChecksums[tileKey] = tileData.checksum;
                            }
                            
                            // Successfully loaded the tile
                            break;
                        } else {
                            // We had a more recent local update, don't overwrite
                            console.log(`Skipping update for tile ${tileKey} due to more recent local change`);
                            break;
                        }
                    } else {
                        // Empty tile
                        renderEmptyTile(tileKey);
                        break;
                    }
                } catch (error) {
                    console.error(`Error loading tile ${tileKey}:`, error);
                    if (retryCount < maxRetries) {
                        retryCount++;
                        await new Promise(resolve => setTimeout(resolve, 500 * retryCount));
                        continue;
                    }
                    loadedTiles.delete(tileKey);
                    renderEmptyTile(tileKey);
                    break;
                } finally {
                    showLoading(false);
                }
            }
        }
        
        function renderEmptyTile(tileKey) {
            const tile = tileElements[tileKey];
            if (!tile) return;
            
            const ctx = tile.getContext('2d');
            
            // Clear the tile first
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(0, 0, TILE_SIZE, TILE_SIZE);
            
            // Create a checker pattern
            ctx.fillStyle = '#333333';
            const checkerSize = 4; // Size of each checker square
            
            for (let y = 0; y < TILE_SIZE; y += checkerSize) {
                for (let x = 0; x < TILE_SIZE; x += checkerSize) {
                    // Only fill alternate squares to create checker pattern
                    if ((Math.floor(x / checkerSize) + Math.floor(y / checkerSize)) % 2 === 0) {
                        ctx.fillRect(x, y, checkerSize, checkerSize);
                    }
                }
            }
            
            // Optionally, you can still draw the grid lines on top
            ctx.strokeStyle = '#444444';
            ctx.lineWidth = 0.5;
            
            // Draw grid lines
            for (let i = 0; i <= TILE_SIZE; i += 16) {
                // Vertical line
                ctx.beginPath();
                ctx.moveTo(i, 0);
                ctx.lineTo(i, TILE_SIZE);
                ctx.stroke();
                
                // Horizontal line
                ctx.beginPath();
                ctx.moveTo(0, i);
                ctx.lineTo(TILE_SIZE, i);
                ctx.stroke();
            }
        }
        
        function renderTile(tileKey, pixels, isPartialUpdate = true) {
            const tile = tileElements[tileKey];
            if (!tile) return;
            
            const [tileX, tileY] = tileKey.split(',').map(Number);
            const ctx = tile.getContext('2d');
            
            // If this is a full tile update (not incremental), clear the tile and draw checker pattern first
            if (!isPartialUpdate) {
                // First clear the tile
                ctx.clearRect(0, 0, TILE_SIZE, TILE_SIZE);
                
                // Draw checker pattern for the entire tile
                for (let y = 0; y < TILE_SIZE; y++) {
                    for (let x = 0; x < TILE_SIZE; x++) {
                        // Calculate global coordinates for correct checker pattern alignment
                        const globalX = tileX * TILE_SIZE + x;
                        const globalY = tileY * TILE_SIZE + y;
                        
                        // Determine checker color based on position
                        if ((globalX + globalY) % 2 === 0) {
                            ctx.fillStyle = '#444444'; // Darker gray
                        } else {
                            ctx.fillStyle = '#666666'; // Lighter gray
                        }
                        ctx.fillRect(x, y, 1, 1);
                    }
                }
            }
            
            // Draw each pixel from the data
            if (pixels && pixels.length) {
                // Create a map of existing pixels for faster lookup
                const pixelMap = {};
                for (const pixel of pixels) {
                    const localX = pixel.x - (tileX * TILE_SIZE);
                    const localY = pixel.y - (tileY * TILE_SIZE);
                    
                    if (localX >= 0 && localX < TILE_SIZE && localY >= 0 && localY < TILE_SIZE) {
                        // Skip null/invalid pixels
                        if (pixel.r === null || pixel.g === null || pixel.b === null) {
                            continue;
                        }
                        
                        ctx.fillStyle = `rgb(${pixel.r}, ${pixel.g}, ${pixel.b})`;
                        ctx.fillRect(localX, localY, 1, 1);
                        
                        // Mark this position as filled
                        pixelMap[`${localX},${localY}`] = true;
                    }
                }
                
                // If this is a partial update and we're not preserving the checker pattern,
                // then we don't need to do anything more
                if (isPartialUpdate) {
                    return;
                }
            }
        }
        
        function startUpdateCycle() {
            // Initial update
            fetchUpdates();
            
            // Poll for updates more frequently (every 1 second instead of 2)
            setInterval(fetchUpdates, 1000);
            
            // Refresh active tiles less frequently to avoid overwhelming the server
            setInterval(refreshActiveTiles, 15000);
        }
        
        async function fetchUpdates() {
            try {
                // Add timestamp to prevent caching
                const timestamp = Date.now();
                
                // Collect checksums of visible tiles to include in the request
                const visibleChecksums = {};
                for (const tileKey of visibleTiles) {
                    if (tileChecksums[tileKey]) {
                        visibleChecksums[tileKey] = tileChecksums[tileKey];
                    }
                }
                
                // Build request with checksums and timestamp
                const params = new URLSearchParams({
                    since: lastUpdateTimestamp,
                    t: timestamp
                });
                
                // Send request with checksums in the body
                const response = await fetch(`${API_BASE}/updates?${params.toString()}`, {
                    method: 'POST',
                    headers: getAuthHeaders(),
                    body: JSON.stringify({
                        checksums: visibleChecksums
                    })
                });
                
                if (!response.ok) {
                    // Don't spam the console for repeat errors
                    if (!window.lastFetchErrorTimestamp || 
                        Date.now() - window.lastFetchErrorTimestamp > 10000) {
                        console.error(`Server responded with status: ${response.status}`);
                        window.lastFetchErrorTimestamp = Date.now();
                    }
                    return;
                }
                
                // Clear the error timestamp if successful
                window.lastFetchErrorTimestamp = null;
                
                const text = await response.text();
                
                // Handle empty response
                if (!text.trim()) return;
                
                // Parse response (handle PHP warnings)
                let data;
                try {
                    let cleanText = text;
                    
                    // If there are PHP warnings, extract just the JSON part
                    if (text.includes('<br />') && text.includes('{"success"')) {
                        cleanText = text.substring(text.indexOf('{"success"'));
                    }
                    
                    data = JSON.parse(cleanText);
                    
                    if (data.success) {
                        // Handle changed tiles first - these are tiles whose checksums don't match
                        if (data.changedTiles && Object.keys(data.changedTiles).length > 0) {
                            for (const [tileKey, tileData] of Object.entries(data.changedTiles)) {
                                if (loadedTiles.has(tileKey)) {
                                    // Update the tile with the complete data
                                    renderTile(tileKey, tileData.pixels || [], false);
                                    
                                    // Update the checksum
                                    tileChecksums[tileKey] = tileData.checksum;
                                    
                                    // Highlight the tile to show it's been updated
                                    highlightTileUpdate(tileKey);
                                }
                            }
                        }
                        
                        // Then handle individual pixel updates for tiles that haven't changed much
                        if (data.pixels && data.pixels.length > 0) {
                            // Group pixels by tile
                            const tileUpdates = {};
                            const affectedTiles = new Set();
                            
                            for (const pixel of data.pixels) {
                                const tileX = Math.floor(pixel.x / TILE_SIZE);
                                const tileY = Math.floor(pixel.y / TILE_SIZE);
                                const tileKey = `${tileX},${tileY}`;
                                
                                affectedTiles.add(tileKey);
                                
                                if (!tileUpdates[tileKey]) {
                                    tileUpdates[tileKey] = [];
                                }
                                
                                tileUpdates[tileKey].push(pixel);
                            }
                            
                            // Update each affected tile
                            for (const [tileKey, pixels] of Object.entries(tileUpdates)) {
                                if (loadedTiles.has(tileKey) && !data.changedTiles?.[tileKey]) {
                                    // Update if tile is already loaded and wasn't already updated through changedTiles
                                    renderTile(tileKey, pixels, true);
                                    
                                    // Update checksum if provided
                                    if (data.tileChecksums && data.tileChecksums[tileKey]) {
                                        tileChecksums[tileKey] = data.tileChecksums[tileKey];
                                    }
                                    
                                    // Show a subtle indication that a tile updated from another user
                                    highlightTileUpdate(tileKey);
                                }
                            }
                        }
                        
                        // Update timestamp
                        if (data.timestamp > lastUpdateTimestamp) {
                            lastUpdateTimestamp = data.timestamp;
                        }
                    }
                } catch (parseError) {
                    console.error("JSON parse error in updates:", parseError);
                    console.error("Raw response:", text);
                }
            } catch (error) {
                // Don't spam the console for repeat errors
                if (!window.lastFetchErrorTimestamp || 
                    Date.now() - window.lastFetchErrorTimestamp > 10000) {
                    console.error("Error fetching updates:", error);
                    window.lastFetchErrorTimestamp = Date.now();
                }
            }
        }
        
        // Function to highlight a tile that was updated by another user
        function highlightTileUpdate(tileKey, type = 'normal') {
            const tile = tileElements[tileKey];
            if (!tile) return;
            
            // Different highlight colors for different update types
            let highlightColor;
            switch (type) {
                case 'checksum':
                    // Bright update for checksum changes (major changes)
                    highlightColor = 'rgba(255,255,255,0.7)';
                    break;
                case 'pixel':
                    // Subtle update for individual pixel changes
                    highlightColor = 'rgba(255,255,255,0.4)';
                    break;
                default:
                    // Default highlight
                    highlightColor = 'rgba(255,255,255,0.5)';
            }
            
            // Add a brief highlight effect
            tile.style.boxShadow = `0 0 8px ${highlightColor}`;
            
            // Remove the highlight after a short delay
            setTimeout(() => {
                tile.style.boxShadow = 'none';
            }, 300);
        }
        
        // Force a reload of a specific tile
        async function reloadTile(tileKey) {
            if (!tileKey) return;
            
            // Remove from loaded tiles so it will be fetched fresh
            loadedTiles.delete(tileKey);
            
            // Now load the tile again with force reload
            await loadTile(tileKey, true);
        }
        
        // Periodically refresh the most centrally visible tiles
        // This ensures that even if incremental updates are missed, 
        // the view will eventually be consistent
        function refreshActiveTiles() {
            // Only refresh if we're not currently dragging or moving
            if (isDragging || movementAnimationFrame) return;
            
            // Get the center of the viewport
            const rect = canvasContainer.getBoundingClientRect();
            const centerX = (rect.width / 2 - offsetX) / scale;
            const centerY = (rect.height / 2 - offsetY) / scale;
            
            // Calculate the central tile
            const centerTileX = Math.floor(centerX / TILE_SIZE);
            const centerTileY = Math.floor(centerY / TILE_SIZE);
            
            // Only refresh the center tile and immediate vicinity - just 5 tiles total
            // This is less intrusive than refreshing a larger area
            const tilesToCheck = [
                `${centerTileX},${centerTileY}`,           // Center
                `${centerTileX-1},${centerTileY}`,         // Left
                `${centerTileX+1},${centerTileY}`,         // Right
                `${centerTileX},${centerTileY-1}`,         // Top
                `${centerTileX},${centerTileY+1}`          // Bottom
            ];
            
            // Create a batch request to check multiple tile checksums at once
            verifyTileChecksums(tilesToCheck);
        }
        
        // New function to verify tile checksums in batch
        async function verifyTileChecksums(tileKeys) {
            // Only check loaded tiles
            const tilesToVerify = tileKeys.filter(tileKey => {
                const [tileX, tileY] = tileKey.split(',').map(Number);
                return tileX >= 0 && tileX < TILE_COUNT && 
                       tileY >= 0 && tileY < TILE_COUNT && 
                       loadedTiles.has(tileKey);
            });
            
            if (tilesToVerify.length === 0) return;
            
            try {
                // Prepare checksum data
                const checksumData = {};
                tilesToVerify.forEach(tileKey => {
                    if (tileChecksums[tileKey]) {
                        checksumData[tileKey] = tileChecksums[tileKey];
                    }
                });
                
                // If we don't have any checksums to verify, skip
                if (Object.keys(checksumData).length === 0) return;
                
                // Make a batch request to verify multiple checksums at once
                const response = await fetch('get_state.php?verify_checksums=1', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        checksums: checksumData
                    })
                });
                
                if (!response.ok) return;
                
                const data = await response.json();
                
                if (data.success && data.outdatedTiles) {
                    // Process tiles that need updates
                    const refreshQueue = Object.keys(data.outdatedTiles);
                    
                    if (refreshQueue.length > 0) {
                        console.log(`Found ${refreshQueue.length} outdated tiles to refresh`);
                        processRefreshQueue(refreshQueue);
                    }
                }
            } catch (error) {
                console.error("Error verifying tile checksums:", error);
            }
        }
        
        // Process refresh queue sequentially with improved error handling
        async function processRefreshQueue(queue) {
            if (queue.length === 0) return;
            
            const tileKey = queue.shift();
            
            try {
                // Remove from loaded tiles so it will be fetched fresh
                loadedTiles.delete(tileKey);
                
                // Now load the tile again with force reload
                await loadTile(tileKey, true);
                
                // Short delay between tile refreshes
                if (queue.length > 0) {
                    setTimeout(() => {
                        processRefreshQueue(queue);
                    }, 100);
                }
            } catch (error) {
                console.error(`Error refreshing tile ${tileKey}:`, error);
                
                // Continue with next tile even if there was an error
                if (queue.length > 0) {
                    setTimeout(() => {
                        processRefreshQueue(queue);
                    }, 100);
                }
            }
        }
        
        // Add new function for continuous drawing
        function handleCanvasMouseMove(e) {
            updateCursorPosition(e.clientX, e.clientY);
            
            if (!consecutivePlacementMode || !e.buttons) return;
            
            // Get current position
            const rect = canvasContainer.getBoundingClientRect();
            const canvasX = Math.floor((e.clientX - rect.left - offsetX) / scale);
            const canvasY = Math.floor((e.clientY - rect.top - offsetY) / scale);
            
            // Ensure coordinates are within board bounds
            if (canvasX >= 0 && canvasX < BOARD_SIZE && canvasY >= 0 && canvasY < BOARD_SIZE) {
                // Use a throttled version to avoid overwhelming the server
                const now = Date.now();
                if (!window.lastPixelPlacement || now - window.lastPixelPlacement > 50) { // 50ms throttle
                    window.lastPixelPlacement = now;
                    placePixel(canvasX, canvasY, true); // true = batch mode
                }
            }
        }
        
        // Replace the placePixel function with this improved version (around line 729)
        async function placePixel(x, y, batchMode = false) {
            try {
                // Skip if out of bounds
                if (x < 0 || x >= BOARD_SIZE || y < 0 || y >= BOARD_SIZE) return;
                
                // Parse the selected color to RGB components
                const r = parseInt(selectedColor.substring(1, 3), 16);
                const g = parseInt(selectedColor.substring(3, 5), 16);
                const b = parseInt(selectedColor.substring(5, 7), 16);
                
                // Calculate tile coordinates 
                const tileX = Math.floor(x / TILE_SIZE);
                const tileY = Math.floor(y / TILE_SIZE);
                const tileKey = `${tileX},${tileY}`;
                
                // If we've failed too many times on this tile in batch mode, skip
                if (batchMode && tileLocalChanges[tileKey] && tileLocalChanges[tileKey].failures > 3) {
                    return;
                }
                
                // Update pixel locally first for immediate feedback
                updateLocalPixel(x, y, r, g, b);
                
                // Keep track of local changes for this tile
                if (!tileLocalChanges[tileKey]) {
                    tileLocalChanges[tileKey] = {
                        pixels: [],
                        lastChecksum: tileChecksums[tileKey] || null,
                        failures: 0
                    };
                }
                
                // Add this pixel to local changes
                tileLocalChanges[tileKey].pixels.push({x, y, r, g, b});
                
                // In batch mode, we collect pixels and send them less frequently
                if (batchMode) {
                    // If we already have a batch in progress, just exit - the pixel is already drawn locally
                    if (batchPlacementInProgress) return;
                    
                    // If this is a new tile in continuous drawing, we should send right away
                    const needsImmediateSend = lastPlacedTile !== tileKey;
                    lastPlacedTile = tileKey;
                    
                    // If we don't need to send right away, wait a bit to collect more pixels
                    if (!needsImmediateSend) {
                        // Check if we have a pending timeout
                        if (window.batchPlacementTimeout) {
                            return;  // Already have a pending batch, just wait
                        }
                        
                        // Set a timeout to send these pixels soon
                        window.batchPlacementTimeout = setTimeout(() => {
                            window.batchPlacementTimeout = null;
                            sendPixelToServer(x, y, r, g, b, tileKey, true);
                        }, 300); // Send batch after 300ms
                        
                        return;
                    }
                }
                
                // Show a temporary notification
                let placingNotification;
                if (!batchMode) {
                    placingNotification = showNotification(`Placing pixel at (${x}, ${y})...`, 'info', 0);
                }
                
                await sendPixelToServer(x, y, r, g, b, tileKey, batchMode, placingNotification);
                
            } catch (error) {
                console.error("Error placing pixel:", error);
                if (!batchMode) {
                    showNotification(`Error: ${error.message}`, 'error');
                }
            }
        }
        
        // New helper function to handle the server communication part of pixel placement
        async function sendPixelToServer(x, y, r, g, b, tileKey, batchMode = false, placingNotification = null) {
            try {
                batchPlacementInProgress = true;
                showLoading(true);
                
                // Send pixel data to server with current checksum
                const pixelData = { 
                    x, y, r, g, b
                };
                
                // Add the current checksum if we have it
                if (tileChecksums[tileKey]) {
                    pixelData.checksum = tileChecksums[tileKey];
                }
                
                // Retry logic for server errors
                let retryCount = 0;
                const maxRetries = batchMode ? 1 : 2; // Fewer retries in batch mode
                
                while (retryCount <= maxRetries) {
                    try {
                        const response = await fetch(`${API_BASE}/pixel`, {
                            method: 'POST',
                            headers: getAuthHeaders(),
                            body: JSON.stringify(pixelData)
                        });
                        
                        if (!response.ok) {
                            if (response.status === 500 && retryCount < maxRetries) {
                                // Server error - retry
                                retryCount++;
                                await new Promise(resolve => setTimeout(resolve, 500 * retryCount));
                                continue;
                            }
                            
                            // Remove the placing notification
                            if (placingNotification) placingNotification.remove();
                            
                            // In batch mode, just count the failure and move on
                            if (batchMode) {
                                if (tileLocalChanges[tileKey]) {
                                    tileLocalChanges[tileKey].failures++;
                                }
                                break;
                            }
                            
                            showNotification(`Error (${response.status}): Failed to place pixel`, 'error');
                            break;
                        }
                        
                        const data = await response.json();
                        
                        // Remove the placing notification
                        if (placingNotification) placingNotification.remove();
                        
                        if (data.success) {
                            // Clear our local changes tracking for this successful update
                            if (tileLocalChanges[tileKey]) {
                                tileLocalChanges[tileKey].pixels = [];
                                tileLocalChanges[tileKey].failures = 0;
                                tileLocalChanges[tileKey].lastChecksum = data.checksum;
                            }
                            
                            // Show success notification only in non-batch mode
                            if (!batchMode) {
                                showNotification(`Pixel placed at (${x}, ${y})`, 'success', 1500);
                            }
                            
                            // Update tile checksum if provided
                            if (data.checksum) {
                                tileChecksums[tileKey] = data.checksum;
                            }
                            
                            // Update stats if provided
                            if (data.stats) {
                                stats.innerHTML = `
                                    <div>Your pixels: ${data.stats.user_pixels || 0}</div>
                                    <div>Total pixels: ${data.stats.total_pixels || 0}</div>
                                    <div>Active users: ${data.stats.active_users || 0}</div>
                                `;
                                // Make stats visible now that we have data
                                stats.style.visibility = 'visible';
                            }
                            
                            break;
                        } else {
                            // Handle error from new API
                            if (!batchMode) {
                                showNotification(`Error: ${data.detail || 'Unknown error'}`, 'error');
                            }
                            break;
                        }
                    } catch (serverError) {
                        console.error("Server error:", serverError);
                        
                        if (retryCount < maxRetries) {
                            retryCount++;
                            await new Promise(resolve => setTimeout(resolve, 500 * retryCount));
                            continue;
                        }
                        
                        // In batch mode, just count the failure
                        if (batchMode) {
                            if (tileLocalChanges[tileKey]) {
                                tileLocalChanges[tileKey].failures++;
                            }
                            break;
                        }
                        
                        // Remove the placing notification
                        if (placingNotification) placingNotification.remove();
                        
                        showNotification(`Server error: ${serverError.message}`, 'error');
                        break;
                    }
                }
            } finally {
                batchPlacementInProgress = false;
                showLoading(false);
            }
        }
        
        function updateLocalPixel(x, y, r, g, b) {
            // Calculate which tile this pixel belongs to
            const tileX = Math.floor(x / TILE_SIZE);
            const tileY = Math.floor(y / TILE_SIZE);
            const tileKey = `${tileX},${tileY}`;
            
            // Record the timestamp of this update
            tileUpdateTimestamps[tileKey] = Date.now();
            
            // Create tile if it doesn't exist
            if (!tileElements[tileKey]) {
                const tile = document.createElement('canvas');
                tile.width = TILE_SIZE;
                tile.height = TILE_SIZE;
                tile.className = 'tile';
                tile.style.left = `${tileX * TILE_SIZE}px`;
                tile.style.top = `${tileY * TILE_SIZE}px`;
                
                pixelCanvas.appendChild(tile);
                tileElements[tileKey] = tile;
                loadedTiles.add(tileKey);
            }
            
            // Update the pixel on the tile
            const tile = tileElements[tileKey];
            const ctx = tile.getContext('2d');
            
            // Calculate local coordinates
            const localX = x - (tileX * TILE_SIZE);
            const localY = y - (tileY * TILE_SIZE);
            
            ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
            ctx.fillRect(localX, localY, 1, 1);
        }
        
        function showLoading(visible) {
            loading.classList.toggle('visible', visible);
        }
        
        function showNotification(message, type = 'info', duration = 3000) {
            const notification = document.createElement('div');
            notification.className = `notification ${type}`;
            notification.textContent = message;
            
            document.body.appendChild(notification);
            
            // Remove after duration
            if (duration > 0) {
                setTimeout(() => {
                    notification.classList.add('fade-out');
                    setTimeout(() => notification.remove(), 500);
                }, duration);
            }
            
            return notification;
        }
        
        // Function to update the current color display
        function updateColorDisplay(colorHex) {
            const currentColorPreview = document.getElementById('currentColorPreview');
            const currentColorText = document.getElementById('currentColorText');
            
            currentColorPreview.style.backgroundColor = colorHex;
            currentColorText.textContent = colorHex.toUpperCase();
            
            // Also update the custom color input to match
            const customColorInput = document.getElementById('customColorInput');
            customColorInput.value = colorHex;
        }
    </script>
</body>
</html> 